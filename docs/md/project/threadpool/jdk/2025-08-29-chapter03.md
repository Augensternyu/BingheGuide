---
title: 第03节：线程池执行任务的核心流程解析
pay: https://articles.zsxq.com/id_imdnb4762qtw.html
---

# 《手写线程池》线程池核心技术-第03节：线程池执行任务的核心流程解析

作者：冰河
<br/>星球：[http://m6z.cn/6aeFbs](http://m6z.cn/6aeFbs)
<br/>博客：[https://binghe.gitcode.host](https://binghe.gitcode.host)
<br/>文章汇总：[https://binghe.gitcode.host/md/all/all.html](https://binghe.gitcode.host/md/all/all.html)
<br/>源码获取地址：[https://t.zsxq.com/0dhvFs5oR](https://t.zsxq.com/0dhvFs5oR)

> 沉淀，成长，突破，帮助他人，成就自我。

* 本章难度：★★★☆☆
* 本章重点：简单介绍线程池执行任务的核心流程，重点掌握：线程池正确运行的核心流程和线程池执行任务的核心流程等核心技术。从全局视角掌握线程池的核心技术原理，学会融汇贯通，将线程池的编程思想灵活应用到自身实际项目中，提升实际项目的并发处理能力，以及自身的并发编程内功功底。

**大家好，我是冰河~~**

在前面的文章中，主要介绍了线程池的基本概述与线程池的顶层接口和抽象类，从总体框架层面介绍了线程池实现的功能。本节，就开始深入线程池实现的细节，深入探讨线程池正确运行的核心流程和线程池执行任务的核心流程。

## 一、前言

上一节中，主要对线程池的总体结构进行了简单的介绍，包括线程池的简介和线程池顶层的接口和抽象类。在介绍线程池时，重点介绍了线程池的概述信息，线程池的优点，Executors工具类和ThreadPoolExecutor类。

在介绍线程池的顶层接口和抽象类时，首先从整体角度介绍了相应的接口和抽象类，随后，从源码角度详细分析了Executor接口、ExecutorServcie接口、AbstractExecutorService抽象类和ScheduledExecutorService接口的底层实现。接下来，继续深入线程池的细节执行流程，深入探讨线程池正确运行的核心流程和线程池执行任务的核心流程。

## 二、本节诉求

简单介绍线程池执行任务的核心流程，重点掌握：线程池正确运行的核心流程和线程池执行任务的核心流程等核心技术。从全局视角掌握线程池的核心技术原理，学会融汇贯通，将线程池的编程思想灵活应用到自身实际项目中，提升实际项目的并发处理能力，以及自身的并发编程内功功底。

## 三、线程池正确运行的核心流程

ThreadPoolExecutor类作为线程池中最核心的实现类，其内部定义的一些常量、方法和内部类对线程池整体逻辑的正确运行起到了至关重要的作用。

### 3.1 ThreadPoolExecutor类中的重要属性

在ThreadPoolExecutor类中，存在着几个非常重要的常量和方法。其中，有一个AtomicInteger类型的常量ctl，这个常量是一个原子类对象，贯穿线程池的整个生命周期，主要用来保存线程的数量和线程池的状态。ThreadPoolExecutor类中与ctl常量相关的属性如下所示。

```java
//主要用来保存线程数量和线程池的状态，高3位保存线程状态，低29位保存线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//线程池中线程的数量的位数（32-3）
private static final int COUNT_BITS = Integer.SIZE - 3;
//表示线程池中的最大线程数量
//将数字1的二进制值向右移29位，再减去1
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
//线程池的运行状态
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
//获取线程状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
private static boolean runStateLessThan(int c, int s) {
	return c < s;
}
private static boolean runStateAtLeast(int c, int s) {
	return c >= s;
}
private static boolean isRunning(int c) {
	return c < SHUTDOWN;
}
private boolean compareAndIncrementWorkerCount(int expect) {
	return ctl.compareAndSet(expect, expect + 1);
}
private boolean compareAndDecrementWorkerCount(int expect) {
	return ctl.compareAndSet(expect, expect - 1);
}
private void decrementWorkerCount() {
	do {} while (! compareAndDecrementWorkerCount(ctl.get()));
}
```

由上述源码可以看出，线程池中的核心状态包括：RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED，这些状态从本质上就构成了线程池的整个生命周期。

**注意：有关线程池中核心状态的说明与状态的流转过程，小伙伴们参见：《[第01节：线程池核心原理技术解析](https://articles.zsxq.com/id_es9ekcwm595m.html)》，这里不再赘述。**

除了ctl相关的属性外，ThreadPoolExecutor类中还提供了一些其他的重要属性。

```java
//用于存放任务的阻塞队列  
private final BlockingQueue<Runnable> workQueue;
//可重入锁
private final ReentrantLock mainLock = new ReentrantLock();
//存放线程池中线程的集合，访问这个集合时，必须获得mainLock锁
private final HashSet<Worker> workers = new HashSet<Worker>();
//在锁内部阻塞等待条件完成
private final Condition termination = mainLock.newCondition();
//线程工厂，以此来创建新线程
private volatile ThreadFactory threadFactory;
//拒绝策略
private volatile RejectedExecutionHandler handler;
//默认的拒绝策略
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
```

上述源码中，每个属性给出了详细的注释，这里也不再赘述。

### 3,2 ThreadPoolExecutor类中的重要内部类

在ThreadPoolExecutor类中存在着对于线程池的执行至关重要的内部类，分别是Worker内部类和拒绝策略内部类。接下来，就分别对这些内部类进行简单的介绍。 

**1.Worker内部类**

Worker类从源码角度来看，继承了AQS类，实现了Runnable接口，本质上就是在线程池中执行任务的线程，Worker类的整体源码如下所示。

## 查看完整文章

加入[冰河技术](https://public.zsxq.com/groups/48848484411888.html)知识星球，解锁完整技术文章、小册、视频与完整代码